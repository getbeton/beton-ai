# PRD 2.1: Add OpenAI Integration Service

## Users
- **Business Users**: Companies and organizations that want to leverage OpenAI's capabilities for data enrichment, content generation, and analysis
- **Technical Users**: Developers and system administrators who need to integrate OpenAI into their existing workflows
- **End Users**: Individuals who will benefit from AI-powered features like email generation, data analysis, and content creation

## Problem
Currently, our platform only supports Apollo integrations for data enrichment and search capabilities. Users increasingly need access to OpenAI's powerful language models for:
- **Content Generation**: Creating emails, summaries, and marketing copy
- **Data Analysis**: Analyzing scraped data and extracting insights
- **Text Processing**: Summarizing, translating, and reformatting content
- **Decision Support**: Getting AI-powered recommendations and analysis

Without OpenAI integration, users must:
- Use separate tools and platforms for AI-powered content generation
- Manually process and analyze data without AI assistance
- Miss opportunities to leverage large language models for business insights
- Manage multiple separate API integrations outside our platform

## Background
Our platform already has a robust integration framework with Apollo, featuring:
- **Service Factory Pattern**: Centralized service management with validation capabilities
- **API Key Management**: Support for both personal and platform keys
- **Integration CRUD**: Full lifecycle management for integrations
- **Health Monitoring**: Automated API key validation and health checks
- **Database Schema**: Existing models for integrations, API keys, and platform keys

The OpenAI API offers:
- **GPT Models**: Advanced text generation and analysis (GPT-4, GPT-3.5-turbo)
- **Embeddings**: Vector representations for semantic search and similarity
- **Fine-tuning**: Custom model training capabilities
- **Structured Outputs**: JSON and schema-based responses
- **Function Calling**: Integration with external tools and APIs

## How it should be

### Entities

#### New Database Entities
No new database entities required - leveraging existing integration framework:
- `Integration` (existing) - with serviceName = 'openai'
- `ApiKey` (existing) - for personal OpenAI API keys
- `PlatformApiKey` (existing) - for shared OpenAI API keys

#### New Service Entities
```typescript
interface OpenAIHealthCheck {
  isHealthy: boolean;
  status: 'healthy' | 'unhealthy' | 'unknown';
  message: string;
  responseTime?: number;
}

interface OpenAICapabilities {
  models: string[];
  supportedOperations: string[];
  rateLimits: {
    requestsPerMinute: number;
    tokensPerMinute: number;
  };
}

interface OpenAIUsageMetrics {
  totalTokens: number;
  promptTokens: number;
  completionTokens: number;
  estimatedCost: number;
}
```

### Systems

#### Backend Services
1. **OpenAIService** (`backend/src/services/openaiService.ts`)
   - API key validation via health check
   - Text generation and completion
   - Usage tracking and cost estimation
   - Error handling and retry logic

2. **ServiceFactory Updates** (`backend/src/services/serviceFactory.ts`)
   - Add OpenAI service registration
   - Enable validation capabilities
   - Support for multiple service types

3. **Integration Routes** (`backend/src/routes/integrations.ts`)
   - OpenAI-specific endpoints
   - API key validation
   - Usage metrics reporting

#### Frontend Components
1. **OpenAI Integration Management**
   - Create/edit OpenAI integrations
   - API key input and validation
   - Usage monitoring dashboard

2. **OpenAI Action Components**
   - Text generation interface
   - Content analysis tools
   - Batch processing capabilities

### User Flow

#### Integration Setup Flow
1. **Navigation**: User navigates to Dashboard → Integrations
2. **Service Selection**: User clicks "Add Integration" → Selects "OpenAI"
3. **Configuration**: 
   - Choose key source (Personal API Key or Platform Key)
   - Enter OpenAI API key if using personal key
   - Set integration name and description
4. **Validation**: System validates API key using OpenAI health endpoint
5. **Creation**: Integration created and activated
6. **Confirmation**: User sees success message and integration appears in list

#### Usage Flow
1. **Integration Selection**: User selects active OpenAI integration
2. **Action Selection**: User chooses action (text generation, analysis, etc.)
3. **Input Configuration**: User provides prompts, parameters, and settings
4. **Processing**: System makes API call to OpenAI
5. **Results Display**: User sees generated content or analysis results
6. **Usage Tracking**: System tracks token usage and costs

### New Tech

#### Required Dependencies
```json
{
  "openai": "^4.67.0",
  "zod": "^3.22.0"
}
```

#### Environment Variables
```bash
# Platform OpenAI Key (optional)
OPENAI_PLATFORM_API_KEY=sk-...

# OpenAI Configuration
OPENAI_DEFAULT_MODEL=gpt-4o-mini
OPENAI_MAX_TOKENS=4000
OPENAI_TEMPERATURE=0.7
```

#### TypeScript Types
```typescript
interface OpenAIConfig {
  apiKey: string;
  baseURL?: string;
  defaultModel: string;
  maxTokens: number;
  temperature: number;
}

interface OpenAIRequest {
  prompt: string;
  model?: string;
  maxTokens?: number;
  temperature?: number;
  systemPrompt?: string;
}

interface OpenAIResponse {
  content: string;
  usage: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  model: string;
  finishReason: string;
}
```

## Acceptance Criteria & Test Cases

### Core Integration Management
✅ **AC1**: Users can create OpenAI integrations with personal API keys
- User navigates to integrations page
- User selects "Add Integration" → "OpenAI"
- User enters valid OpenAI API key
- System validates key and creates integration
- Integration appears in user's integration list

✅ **AC2**: System validates OpenAI API keys during creation
- User enters invalid API key
- System shows error message: "Invalid OpenAI API key"
- User enters valid API key
- System shows success message and creates integration

✅ **AC3**: Users can edit and update OpenAI integrations
- User clicks "Edit" on existing OpenAI integration
- User can modify name, description, and API key
- System re-validates API key if changed
- Changes are saved and reflected in integration list

✅ **AC4**: Users can delete OpenAI integrations
- User clicks "Delete" on OpenAI integration
- System shows confirmation dialog
- User confirms deletion
- Integration is removed from list and database

### API Key Management
✅ **AC5**: System supports both personal and platform API keys
- Admin can configure platform-wide OpenAI API key
- Users can choose between personal and platform keys
- Platform key usage is tracked per integration
- Personal keys are encrypted and stored securely

✅ **AC6**: API key validation provides clear feedback
- Valid key: "OpenAI API key is valid and healthy"
- Invalid key: "Invalid OpenAI API key format"
- Network error: "Unable to connect to OpenAI API"
- Rate limit: "OpenAI API rate limit exceeded"

### Service Implementation
✅ **AC7**: OpenAI service integrates with ServiceFactory
- ServiceFactory.getService('openai') returns OpenAI service
- ServiceFactory.supportsValidation('openai') returns true
- Service validation works through factory pattern
- Error handling consistent with other services

✅ **AC8**: OpenAI service provides health check functionality
- Health check calls OpenAI API to validate key
- Returns structured health response
- Includes response time measurements
- Handles various error scenarios gracefully

### Basic OpenAI Operations
✅ **AC9**: System can generate text using OpenAI API
- User provides text prompt
- System calls OpenAI API with prompt
- Returns generated text response
- Tracks token usage and costs

✅ **AC10**: System handles OpenAI API errors gracefully
- Invalid API key: Returns clear error message
- Rate limit exceeded: Implements retry logic
- Network timeout: Returns timeout error
- API quota exceeded: Returns quota error

### Usage Tracking
✅ **AC11**: System tracks OpenAI API usage
- Records prompt tokens used
- Records completion tokens used
- Calculates total tokens and estimated cost
- Stores usage metrics per integration

✅ **AC12**: Users can view OpenAI usage statistics
- Integration details show total usage
- Usage includes token counts and costs
- Historical usage data available
- Usage resets appropriately per billing cycle

### Integration Testing
✅ **AC13**: OpenAI integration works with existing infrastructure
- Integrates with existing authentication system
- Uses existing database models
- Follows existing API patterns
- Maintains existing security practices

✅ **AC14**: Frontend components handle OpenAI operations
- Create integration form validates input
- Integration list displays OpenAI integrations
- Edit functionality works correctly
- Delete functionality works correctly

### Error Handling & Security
✅ **AC15**: API keys are stored securely
- Personal API keys encrypted in database
- Platform keys stored in secure environment variables
- Keys never exposed in client-side code
- Audit logging for key usage

✅ **AC16**: System handles rate limiting appropriately
- Implements exponential backoff for retries
- Provides clear error messages for rate limits
- Queues requests when appropriate
- Graceful degradation when limits reached

### Performance & Scalability
✅ **AC17**: OpenAI integration performs efficiently
- API calls complete within reasonable timeframes
- Concurrent requests handled appropriately
- Memory usage remains stable
- Database queries optimized

✅ **AC18**: System supports multiple OpenAI integrations per user
- Users can create multiple OpenAI integrations
- Each integration tracked separately
- Usage metrics isolated per integration
- No interference between integrations

## Implementation Phases

### Phase 1: Core Service Implementation (Week 1)
- Create OpenAIService class
- Implement API key validation
- Add service to ServiceFactory
- Create basic health check functionality

### Phase 2: Integration Management (Week 2)
- Update integration routes for OpenAI
- Add OpenAI service to frontend integration forms
- Implement CRUD operations for OpenAI integrations
- Add API key validation to frontend

### Phase 3: Basic Operations (Week 3)
- Implement text generation functionality
- Add usage tracking and metrics
- Create OpenAI-specific endpoints
- Add error handling and retry logic

### Phase 4: UI/UX & Polish (Week 4)
- Create OpenAI integration management UI
- Add usage dashboards and monitoring
- Implement comprehensive error handling
- Add documentation and help text

### Phase 5: Testing & Deployment (Week 5)
- Comprehensive testing of all functionality
- Performance testing and optimization
- Security audit and validation
- Production deployment and monitoring

## Technical Specifications

### API Endpoints
```
POST /api/integrations (with serviceName: 'openai')
GET /api/integrations (filters OpenAI integrations)
PUT /api/integrations/:id (updates OpenAI integration)
DELETE /api/integrations/:id (deletes OpenAI integration)
POST /api/integrations/:id/health-check (OpenAI health check)
POST /api/integrations/:id/openai/generate (text generation)
GET /api/integrations/:id/openai/usage (usage metrics)
```

### Database Schema Updates
No new tables required - using existing integration schema:
```sql
-- Example OpenAI integration record
INSERT INTO integrations (
  id, userId, serviceName, name, keySource, 
  platformKeyId, isActive, healthStatus
) VALUES (
  'cuid', 'user123', 'openai', 'My OpenAI Integration', 
  'personal', NULL, true, 'healthy'
);

-- Example platform key record
INSERT INTO platform_api_keys (
  id, serviceName, apiKey, isActive, description
) VALUES (
  'cuid', 'openai', 'sk-...', true, 'Platform OpenAI Key'
);
```

### Security Considerations
- API keys encrypted at rest using AES-256
- All API calls made server-side only
- Rate limiting implemented to prevent abuse
- Audit logging for all OpenAI API usage
- Content filtering for inappropriate requests
- Token usage monitoring and alerting

## Success Metrics
- Number of OpenAI integrations created
- API key validation success rate
- Average response time for OpenAI operations
- Token usage and cost tracking accuracy
- User satisfaction with OpenAI integration
- System uptime and reliability metrics

## Future Enhancements
- Support for OpenAI Assistant API
- Custom model fine-tuning capabilities
- Advanced function calling integration
- Batch processing for large datasets
- Custom prompt templates and libraries
- Integration with other AI services
